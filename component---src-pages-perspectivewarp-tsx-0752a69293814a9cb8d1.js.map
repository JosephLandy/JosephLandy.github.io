{"version":3,"sources":["webpack:///./src/pages/perspectivewarp.tsx","webpack:///./src/utils.ts"],"names":["imgURL","cardsURL","PerspectiveWarp","props","srcPoints","setSrcPoints","useState","targetPoints","setTargetPoints","showWarped","setShowWarped","url","setUrl","image","setImage","useEffect","img","Image","async","Promise","resolve","reject","onload","e","src","console","error","load","undefined","srcStyle","fill","r","font","fontFill","targStyle","css","lighten","colors","darkgrey","type","accept","onChange","files","target","length","URL","createObjectURL","points","clickHandler","p","getMousePos","currentTarget","prev","style","mouseP","x","y","onClick","targPoints","useWindowSize","windowSize","setWindowSize","width","height","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","canvas","evt","rect","getBoundingClientRect","clientX","left","clientY","top"],"mappings":"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","file":"component---src-pages-perspectivewarp-tsx-0752a69293814a9cb8d1.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport PageLayout from '../layouts/page-layout';\n// import cardsImage from '../cardsOnGrid.png';\nimport { getMousePos, Point } from '../utils';\n\nimport CanvasPoints from '../components/CanvasPoints';\n\nimport { css } from '@emotion/core';\nimport { lighten } from 'polished';\nimport { colors } from '../styles/colors';\nimport CanvasWarped from '../components/CanvasWarped';\n// import churchURL from '../images/church.jpeg';\n// import perspectiveURL from '../images/perspective.png';\nimport cardsURL from '../images/cardsOnGrid.png';\n\n// You can use this image for free without changing it as long you include the attribution below:\n// https://bryanmmathers.com/perspective/\n// https://bryanmmathers.com/wp-content/uploads/2016/10/perspective.png\n// Perspective\n// by @bryanMMathers\n// is licenced under CC-BY-ND\n\n// doing this in react is a huge pain in the ass.\n// const imgURL =\n//   'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Cortes_del_Condado_de_Wabash%2C_Wabash%2C_Indiana%2C_Estados_Unidos%2C_2012-11-12%2C_DD_01.jpg/1280px-Cortes_del_Condado_de_Wabash%2C_Wabash%2C_Indiana%2C_Estados_Unidos%2C_2012-11-12%2C_DD_01.jpg';\n\nconst imgURL = cardsURL;\n\ninterface Props {}\n\nconst PerspectiveWarp: React.FC<Props> = props => {\n  const [srcPoints, setSrcPoints] = useState<Point[]>([]);\n  const [targetPoints, setTargetPoints] = useState<Point[]>([]);\n  const [showWarped, setShowWarped] = useState(false);\n\n  const [url, setUrl] = useState(imgURL);\n  const [image, setImage] = useState<HTMLImageElement>();\n\n  useEffect(() => {\n    let img = new Image();\n    const load = async () => {\n      try {\n        await new Promise((resolve, reject) => {\n          img.onload = e => {\n            resolve(null);\n          };\n          img.src = url;\n        });\n        setSrcPoints([]); // reset the points array.\n        setTargetPoints([]);\n        setImage(img);\n      } catch {\n        console.error('something went wrong drawing the image.');\n      }\n    };\n    load();\n    return () => {\n      // I think I can clean up state like this.\n      img.onload = null;\n      setSrcPoints([]);\n      setTargetPoints([]);\n      setImage(undefined);\n    };\n  }, [url]);\n\n  const srcPointHandler: React.MouseEventHandler<HTMLCanvasElement> = e => {\n    const p = getMousePos(e.currentTarget, e);\n    setShowWarped(false);\n    if (targetPoints.length != 0) {\n      setTargetPoints([]);\n    }\n    setSrcPoints(prev => {\n      if (prev.length >= 4) {\n        return [];\n      }\n      return [...prev, p];\n    });\n  };\n\n  const targetPointHandler: React.MouseEventHandler<HTMLCanvasElement> = e => {\n    const mouseP = getMousePos(e.currentTarget, e);\n    // I think I need to choose the bigger possible square.\n    setShowWarped(false);\n    setTargetPoints(prev => {\n      // I need to build a square.\n      switch (prev.length) {\n        case 0:\n          return [mouseP];\n        case 1:\n          return [...prev, { x: mouseP.x, y: prev[0].y }];\n        case 2:\n          // ok, so here we add 2 points, because the 4th point just completes the rectangle\n          // with the first 3 assuming the click order is clockwise.\n          return [...prev, { x: prev[1].x, y: mouseP.y }, { x: prev[0].x, y: mouseP.y }];\n        case 4:\n          return [];\n        default:\n          return [];\n      }\n    });\n  };\n\n  const handleFiles: React.ChangeEventHandler<HTMLInputElement> = e => {\n    let files = e.target.files;\n    if (files && files.length > 0) {\n      setUrl(URL.createObjectURL(files[0]));\n    }\n  };\n\n  // how the points are displayed.\n  const srcStyle = { fill: '#fcba03', r: 6, font: '30px serif', fontFill: '#000' };\n  const targStyle = { ...srcStyle, fill: '#be2de2' };\n\n  return (\n    <PageLayout>\n      <div\n        css={css`\n          margin-top: 20px;\n          button {\n            margin-top: 10px;\n            background-color: ${lighten('0.2', colors.darkgrey)};\n            outline: none;\n          }\n          p {\n            margin: 20px;\n          }\n        `}\n      >\n        <label\n          css={css`\n            padding: 40px;\n          `}\n        >\n          Click here to upload an image.\n          <input type=\"file\" accept=\"image/*\" onChange={handleFiles} />\n        </label>\n\n        <p>\n          Click to select 4 points identifying a feature to display without perspective, in\n          clockwise direction from top left corner. The feature should be a flat surface, viewed in\n          the image at an angle and/or rotated.\n        </p>\n        <CanvasPoints\n          points={srcPoints}\n          clickHandler={srcPointHandler}\n          image={image}\n          style={srcStyle}\n        />\n        {srcPoints.length === 4 && (\n          <>\n            <p>\n              Now select 4 coresponding points defining the rectangle the selected feature will\n              occupy without perspective.\n            </p>\n            <CanvasPoints\n              points={targetPoints}\n              clickHandler={targetPointHandler}\n              image={image}\n              style={targStyle}\n            />\n          </>\n        )}\n        {targetPoints.length === 4 && (\n          <>\n            <p>\n              Click to compute and display the warped image. (May take a few seconds, especially\n              with large images)\n            </p>\n            <button\n              onClick={() => {\n                setShowWarped(true);\n              }}\n            >\n              Generate warped\n            </button>\n          </>\n        )}\n        {targetPoints.length === 4 && image && showWarped && (\n          <CanvasWarped\n            srcPoints={srcPoints}\n            targPoints={targetPoints}\n            image={image}\n            style={targStyle}\n          />\n        )}\n        {/* <button\n          onClick={() => {\n            console.log('src points');\n            console.log(srcPoints);\n            console.log('target points');\n            console.log(targetPoints);\n          }}\n        >\n          print source plus target\n        </button> */}\n      </div>\n    </PageLayout>\n  );\n};\n\nexport default PerspectiveWarp;\n","import { useState, useEffect } from 'react';\n\n// import math from 'mathjs';\n\n// https://usehooks.com/useWindowSize/\nexport function useWindowSize() {\n  // Initialize state with undefined width/height so server and client renders match\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n  const [windowSize, setWindowSize] = useState<{ width?: number; height?: number }>({\n    width: undefined,\n    height: undefined,\n  });\n  useEffect(() => {\n    // Handler to call on window resize\n    function handleResize() {\n      // Set window width/height to state\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Call handler right away so state gets updated with initial window size\n    handleResize();\n\n    // Remove event listener on cleanup\n    return () => window.removeEventListener('resize', handleResize);\n  }, []); // Empty array ensures that effect is only run on mount\n\n  return windowSize;\n}\n\n// lets use a tuple here?\n// type Point = [number, number]\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n\nexport function getMousePos(canvas: Element, evt: React.MouseEvent): Point {\n  let rect = canvas.getBoundingClientRect();\n  return {\n    x: evt.clientX - rect.left,\n    y: evt.clientY - rect.top,\n  };\n}\n\n\n// export function pointToVector(p: Point): math.Matrix {\n//   // return math.matrix([p.x, p.y]);\n// }"],"sourceRoot":""}
{"version":3,"sources":["webpack:///./src/pages/perspectivewarp.tsx","webpack:///./src/images/church.jpeg","webpack:///./src/utils.ts"],"names":["imgURL","churchURL","PerspectiveWarp","props","srcPoints","setSrcPoints","useState","targetPoints","setTargetPoints","showWarped","setShowWarped","url","setUrl","image","setImage","useEffect","img","Image","async","Promise","resolve","reject","onload","e","src","console","error","load","undefined","srcStyle","fill","r","font","fontFill","targStyle","css","lighten","colors","darkgrey","type","accept","onChange","files","target","length","URL","createObjectURL","points","clickHandler","p","getMousePos","currentTarget","prev","style","mouseP","x","y","onClick","targPoints","module","exports","useWindowSize","windowSize","setWindowSize","width","height","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","canvas","evt","rect","getBoundingClientRect","clientX","left","clientY","top"],"mappings":"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","file":"component---src-pages-perspectivewarp-tsx-d19d47976529f3ec4bc7.js","sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport { css } from '@emotion/core';\r\nimport { lighten } from 'polished';\r\nimport { colors } from '../styles/colors';\r\nimport PageLayout from '../layouts/page-layout';\r\n\r\nimport { getMousePos, Point } from '../utils';\r\n\r\nimport CanvasPoints from '../components/CanvasPoints';\r\nimport CanvasWarped from '../components/CanvasWarped';\r\n\r\nimport churchURL from '../images/church.jpeg';\r\n// import cardsURL from '../images/cardsOnGrid.png';\r\n\r\nconst imgURL = churchURL;\r\n\r\ninterface Props {}\r\n\r\nconst PerspectiveWarp: React.FC<Props> = props => {\r\n  const [srcPoints, setSrcPoints] = useState<Point[]>([]);\r\n  const [targetPoints, setTargetPoints] = useState<Point[]>([]);\r\n  const [showWarped, setShowWarped] = useState(false);\r\n\r\n  const [url, setUrl] = useState(imgURL);\r\n  const [image, setImage] = useState<HTMLImageElement>();\r\n\r\n  useEffect(() => {\r\n    let img = new Image();\r\n    const load = async () => {\r\n      try {\r\n        await new Promise((resolve, reject) => {\r\n          img.onload = e => {\r\n            resolve(null);\r\n          };\r\n          img.src = url;\r\n        });\r\n        setSrcPoints([]); // reset the points array.\r\n        setTargetPoints([]);\r\n        setImage(img);\r\n      } catch {\r\n        console.error('something went wrong drawing the image.');\r\n      }\r\n    };\r\n    load();\r\n    return () => {\r\n      // I think I can clean up state like this.\r\n      img.onload = null;\r\n      setSrcPoints([]);\r\n      setTargetPoints([]);\r\n      setImage(undefined);\r\n    };\r\n  }, [url]);\r\n\r\n  const srcPointHandler: React.MouseEventHandler<HTMLCanvasElement> = e => {\r\n    const p = getMousePos(e.currentTarget, e);\r\n    setShowWarped(false);\r\n    if (targetPoints.length != 0) {\r\n      setTargetPoints([]);\r\n    }\r\n    setSrcPoints(prev => {\r\n      if (prev.length >= 4) {\r\n        return [];\r\n      }\r\n      return [...prev, p];\r\n    });\r\n  };\r\n\r\n  const targetPointHandler: React.MouseEventHandler<HTMLCanvasElement> = e => {\r\n    const mouseP = getMousePos(e.currentTarget, e);\r\n    setShowWarped(false);\r\n    setTargetPoints(prev => {\r\n      // Build a rectangle.\r\n      switch (prev.length) {\r\n        case 0:\r\n          return [mouseP];\r\n        case 1:\r\n          return [...prev, { x: mouseP.x, y: prev[0].y }];\r\n        case 2:\r\n          // ok, so here we add 2 points, because the 4th point just completes the rectangle\r\n          // with the first 3 assuming the click order is clockwise.\r\n          return [...prev, { x: prev[1].x, y: mouseP.y }, { x: prev[0].x, y: mouseP.y }];\r\n        case 4:\r\n          return [];\r\n        default:\r\n          return [];\r\n      }\r\n    });\r\n  };\r\n\r\n  const handleFiles: React.ChangeEventHandler<HTMLInputElement> = e => {\r\n    let files = e.target.files;\r\n    if (files && files.length > 0) {\r\n      setUrl(URL.createObjectURL(files[0]));\r\n    }\r\n  };\r\n\r\n  // how the points are displayed.\r\n  const srcStyle = { fill: '#fcba03', r: 6, font: '30px serif', fontFill: '#000' };\r\n  const targStyle = { ...srcStyle, fill: '#be2de2' };\r\n\r\n  return (\r\n    <PageLayout>\r\n      <div\r\n        css={css`\r\n          margin-top: 20px;\r\n          button {\r\n            margin-top: 10px;\r\n            background-color: ${lighten('0.2', colors.darkgrey)};\r\n            outline: none;\r\n          }\r\n          p {\r\n            margin: 20px;\r\n          }\r\n        `}\r\n      >\r\n        <label\r\n          css={css`\r\n            padding: 40px;\r\n          `}\r\n        >\r\n          Click here to upload an image.\r\n          <input type=\"file\" accept=\"image/*\" onChange={handleFiles} />\r\n        </label>\r\n\r\n        <p>\r\n          Click to select 4 points identifying a feature to display without perspective, in\r\n          clockwise direction from top left corner. The feature should be a flat surface, viewed in\r\n          the image at an angle and/or rotated. For example, one of the window bays in the image of\r\n          the buidling, or the face of one of the columns. Or whatever you want, try it and see what\r\n          happens!\r\n        </p>\r\n        <CanvasPoints\r\n          points={srcPoints}\r\n          clickHandler={srcPointHandler}\r\n          image={image}\r\n          style={srcStyle}\r\n        />\r\n        {srcPoints.length === 4 && (\r\n          <>\r\n            <p>\r\n              Now select 4 coresponding points defining a rectangle that the selected feature will\r\n              be mapped to/occupy in the output image. A rectangle of approximately the same size as\r\n              the feature will result in less distortion.\r\n            </p>\r\n            <CanvasPoints\r\n              points={targetPoints}\r\n              clickHandler={targetPointHandler}\r\n              image={image}\r\n              style={targStyle}\r\n            />\r\n          </>\r\n        )}\r\n        {targetPoints.length === 4 && (\r\n          <>\r\n            <p>\r\n              Click to compute and display the warped image. (May take a few seconds, especially\r\n              with large images)\r\n            </p>\r\n            <button\r\n              onClick={() => {\r\n                setShowWarped(true);\r\n              }}\r\n            >\r\n              Generate\r\n            </button>\r\n          </>\r\n        )}\r\n        {targetPoints.length === 4 && image && showWarped && (\r\n          <CanvasWarped\r\n            srcPoints={srcPoints}\r\n            targPoints={targetPoints}\r\n            image={image}\r\n            style={targStyle}\r\n          />\r\n        )}\r\n      </div>\r\n    </PageLayout>\r\n  );\r\n};\r\n\r\nexport default PerspectiveWarp;\r\n","module.exports = __webpack_public_path__ + \"static/church-4acc3d322218ea01bc7f9f4b86c064f5.jpeg\";","import { useState, useEffect } from 'react';\r\n\r\n// import math from 'mathjs';\r\n\r\n// https://usehooks.com/useWindowSize/\r\nexport function useWindowSize() {\r\n  // Initialize state with undefined width/height so server and client renders match\r\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\r\n  const [windowSize, setWindowSize] = useState<{ width?: number; height?: number }>({\r\n    width: undefined,\r\n    height: undefined,\r\n  });\r\n  useEffect(() => {\r\n    // Handler to call on window resize\r\n    function handleResize() {\r\n      // Set window width/height to state\r\n      setWindowSize({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n      });\r\n    }\r\n    // Add event listener\r\n    window.addEventListener('resize', handleResize);\r\n\r\n    // Call handler right away so state gets updated with initial window size\r\n    handleResize();\r\n\r\n    // Remove event listener on cleanup\r\n    return () => window.removeEventListener('resize', handleResize);\r\n  }, []); // Empty array ensures that effect is only run on mount\r\n\r\n  return windowSize;\r\n}\r\n\r\n// lets use a tuple here?\r\n// type Point = [number, number]\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n\r\nexport function getMousePos(canvas: Element, evt: React.MouseEvent): Point {\r\n  let rect = canvas.getBoundingClientRect();\r\n  return {\r\n    x: evt.clientX - rect.left,\r\n    y: evt.clientY - rect.top,\r\n  };\r\n}\r\n\r\n\r\n// export function pointToVector(p: Point): math.Matrix {\r\n//   // return math.matrix([p.x, p.y]);\r\n// }"],"sourceRoot":""}